---
layout: post
title: "GO:来自非程序员的观点"
date:   2015-01-28 23:33:35
categories: Go
---



GO:来自非程序员的观点

Go是相当年轻的编程语言，出自Google的Robert Griesemer, Rob Pike and Ken Thompson。自从Go 1.0发布以来，这几年慢慢流行起来。

有很多文章，谈论Go的优却点和为什么使用与否。还有一些文章来自一些 Python，Ruby，Node, Rust等等开发者的观点。最近，就我甚至读了几篇为什么Go流行于中国以及为什么中国的开发者这么喜爱Go的博客，这是个很有趣的现象。

这是一篇使用了一段Go以后，我所思考和怎样学到的一些，我对Go的个人看法。但绝非Go与其他语言好坏的比较。

简言之，我喜欢Go。在有限的空闲时间里，GO是第一个，我最近几年一直在用并能真正构建一些有趣项目的语言[SurgeMQ][]。

### 我的背景
我不是程序员。非全职、非兼职。我跟同事和团队说，我是个非技术人员。但是我有技术背景。我拥有理科硕士学位，并且在我的职业生涯里，我有6，7年时间，从事安全审计和渗透测试工作，还构建了在当时世界上最大的安全服务系统之一。

当我还是技术人员时，我的编程语言历程是这样的，BASIC(高中),Pascal and C(大学),Perl,PHP,Java and Javascript(技术职业生涯期间)，我不是以上任何语言的专家，但是我认为在使用他们的时间里，相当的精通它们。

我还有相当网络和系统方面的理解，就这方面来讲，我对Solaris和Linux(UN*X)相当了解。我认为相当的精通各种系统命令和工具。

尽管，过去12年了，我没有成为开发者，系统、网络人员。然后，我成为了在安全和基础设施方面的新兴公司以及大公司的产品管理者。

因为职业的改变，我没有做任何有益的代码开发工作。以前我到处写写脚本，但是我认为都不是软件。但是，管理工程师团队是我的部分职责，还有产品管理以及产生大规模软件。

在过去的12年里，我最常使用的IDE是微软Office。因此，简言之，我是个半技术人员以及知道足够计算机安全危险的人。

### 我和Go的渊源
在2011-2012年，我在VMware，负责组建全新的工程师团队(那时我已经是产品经理了)，以获取新的战略主动性。成熟的产品/服务已经不重要。但那时，团队新生，我们有为项目选择语言的余地。此时的VMare重度使用Java，特别是Spring[2009 acquisition of SpringSource][]。当时新团队大部分都有Java经验，渴望选择一些少点臃肿和比较好的支持他们摆脱分布式软件模式。
##### 首次接触
团队里有些人有Scala经验，因此这是个很显然的选择。我在网上做了一些研究，发现有人在讨论Go。那时，Go还没到1.0,但是可以跑起来了。在Amazon发现一本叫[The way to Go][],这大概是那时唯一一本关于Go的书了吧。有Kindle版本的电子书，3美元，相当的值。但是，Go(1.0以前）还在初期，不是很成熟。不是很合适的选择，因此我就没把它作为一个选择。但是这是我对Go的第一次接触并且还相对无痛的。

因为现在经验，最后团队选择Scala，在理论上，有Java经验的人应该相当容易的迁移到Scala。在VMware，我们是在第一个使用Scala的团队，并且体验是相当兴奋的。

但是，到今天为止，我仍不确定迁移到Scala是个正确的绝定(也不是说错了)，我相信学习曲线比我们当初预期的要高很多。很多开发者用Scala语法写Java代码。招聘也是个问题。基本上，每个新来的开发人员都要被送去安全培训。不过，对于多数从非函数式思维模式的人跳进完全函数式思维还是不容易的。新Scala开发人员和有经验的开发者因为知识的不同，造成合作上的困难。

我也试着专研Scala，至少理解概念。我甚至参加了Martin Odersky提供的Coursera在线课程。但是我就是不能把我的非函数式思维转变成Scala函数式思维。由于我确实不用写代码(或者没有开发者向我这样),我放弃学Scala了。
##### 再次接触
在两年前的2013年第三季度，我已经离开VMware加入我现在的公司Jolata,这是一家为移动公司和繁忙交易的财务服务公司提供大数据网络分析的解决方案的公司。我们是一家小的创业公司，尝试做很多事情。因此，尽管我负责产品，但常常不得不挽起袖子自己也干。

我们不得不为公司创建一个可重复演示的环境。目标是预先建立很多虚拟机泡在我们的Mac电脑上，并无需网络连接演示我们的产品。需要一些有趣数据集以供我们把不同的场景都走一遍。

我们的数据集是网络流，为了使用户界面看起来更真实，有趣，生动，我们想生成一些无关数据使得界面看来是像是在监控真实网络。因为所有的开发人眼都在关注功能的开发上，因为就拿了负责构建数据集的任务。

那时，Go已经发布了1.1版本，1.2也在开发中了。我就开始认真考虑为这个项目使用Go了。构建数据集生成工具，我们要两个库。第一是[Perlin Noise][],第二个是[Google’s Cityhash][]。我记得这两个都不在Go(可能也在)。我想这是个很好的测试Go的机会。我的Go学习是从Perlin和Cityhash项目开始的。

这两个项目相对简单，因为我不需要花很多时间弄清楚怎样实现他们。Perlin Noise是个以为大家接受的C库和算法，Cityhash也是用C写的，因此很容易转化成Go。这些项目使我感受到Go是怎样工作的。

最后，用Go写了数据生成器并体验了goroutines。再次强掉**第二次接触Go也是无痛的**。那时，唯一让我困惑的是Go的源代码树结构。 理解$GOROOT, $GOPATH 和其他Go的环境变量对我来说都是新的。在10年里，这是第一次花时间写的软件。所以我认为这种困惑是由于我缺乏经验。
##### 接下来
现在，有了很多开发人员以后，我不用再写代码了。同时Jolata大部分产品使用C/C++，Java以及Node，因此Go不再混合使用。自从那次Go项目体验了以后，我已经花费大量的个人业余时间在使用它。

我写了各种各样的库，如[bitmap compression][], [integer compression][], [bloom filters][], [skiplist][]等等。并且把我的学习历程记录在我的博客上[blogged my journey][]。通过这些项目，我学到了怎样使用Go的工具链，用Go的习惯写代码，用Go编写测试代码，更重要是怎样优化Go。

有趣的是，我的这篇[Go vs Java: Decoding Billions of Integers Per Second][]文章非常流行。从这点可以看出，许多Java开发人员正是Go的潜在使用者。

所有的这些Go经验使得我能真正构建[SurgeMQ][]这个项目，受欢迎程度远远大于我其他的项目，因此我希望继续开发它。
### 我看GO
以我对Go一年多的使用和观察来看，Go不光是一门语言，也有围绕它的很活跃的社区。我的Go开发环境主要是Sublime Text 3搭配GoSublime插件。
##### 关于语言
我不是语言理论家也不是语言专家。只不是我之前使用过Go。我仅仅听过泛型，CSP(communicating sequential processes),还有很酷很先进的概念。也听说过全新很酷的语言如，Clojure和Rust，但是从来没看过它们的任何代码。所以我对于Go基本上是的开发新手的观点。

某种程度上说，编程语言新手有个好处就是没有先入为主思维。我可以以很自然的方式学习和使用它，不需要经常问：为什么要设计成那样，因为这和我所知道的不同。

其他人会认为这是很大的缺点，因为不还不知道其他更好的语言，用它们构建可能使我的工作更容易，代码更简单。

但是，这个语言没有使用低效，而且能满足我的需求。
##### Go简单
Go非常容易学会，Go的设计相当的简单和最小化。你可以在比较空闲的下午，坐下并通读[Language Specification][]。我第一次接触Go是通读了*The Way to Go*这本书。尽管这本书涉及语言点不是很多，因此和我一样的人学会基本的东西相对很容易。(BTW, 我强烈推荐Go新开发者读下[Go Tour][],但是没有通读过这些。)

Go里有很多先进的概念，如interface,channel,goroutine.Channel通常来说是相当直白的概念。大多数新手应该能很快理解。你写入一些东西，读取一些东西，就这么简单。从那以后，你可以慢慢扩展此概念，如加入缓冲channels，扫描channels，以及检查可读否，或者退出channels。

对于任何人新学一门语言的线程，goroutine也不是很难懂的概念。基本上它就是轻量级的线程能并发执行。你可以把任何函数用goroutine跑起来。

比较困难的应该是interface概念。因为它和其他语言的接口概念有很大的不同。一旦你理解什么是接口，就相当简单的使用它们了。但是，设计自己的接口又是不同的事。

我看到很多人抱怨Go缺乏泛型机制,你可以读下[Summary of Go Generics Discussions][]这篇讨论。我个人不太知道泛型，从来也没有使用过，我没有找到强烈需要它的情况。

开发语言团队认为，小即是多。它允许开发者在极短的时间快速的达到生产力。毕竟，时间就是金钱。
##### Go自我
很多地方Go是有自己坚持的。例如，怎样构建代码目录上Go可能是最令人沮丧的事情。不想其他语言，你只需创建目录就开一开始。Go要求你把它放到$GOPATH中。有些关于这方面的东西[How to Write Go Code][]，理解它的代码组织和怎样导入库花费我太多时间了。

如果回头看我真正意义上的第一个项目，可能会哭，因为所有的组织都是非习惯用法的。但是，一旦我掌握了Go希望的方式组织代码，就不再是我的障碍了。**代替以Go的方式组织事情，使用学会了go的工作流**。最后，$GOPATH的组织结构，跟踪不同包的导入确实很有帮助。

还有一个Go的坚持就是代码格式化。Go和Go的开发者，期望所有的Go程序都用go fmt格式化。许多开发者讨厌职业样，甚至列出作为离开Go的理由。但是，你只需学习go的工作流就好了，个人喜欢这个工作流。

但是，作为团队开发的语言，这样的约定可以节省很多争论的时间，时间就是金钱啊。当时的VMware新开团队，可能花费30人小时在争论代码格式上面，相当于全勤180K美元薪资里的2700美元。这还不算重新格式化不恰当的代码花费的时间。

在变量的使用和包的导入方卖也是有自己的想法。如果变量声明没有使用，编译器就会报错。包导入没有使用，编译器同样会报错。就个人而言，我喜欢编译对未使用的变量报错。这可以保持代码整洁，消除意想不到的bug。我没怎么关心未使用的包的情况，但是要适应编译器。在Sublime Text 3里我用[goimports]()高效、快速的处理import语句。事实上，99%的情况，我不需要自己导入import语言。

##### Go安全
有几个Go安全的理由。新手，Go不会使你变得懒惰。例如，Go是静态类型语言，这意味着每个变量必须显式有个类型和它联系起来。Go编译器在确定的情况下能推断类型，无论如何每个变量都有类型。对于从动态语言过来的人员优点不适应，但是利大于弊。我有第一手的经验，用Node花费很长时间解决故障，我作为产品负责人坐等bug修复。当写完代码后，静态类型能给你一个代码已经写对了的感觉。

Go的错误处理机制是通过函数返回`error`来确保你不会变懒。也有很多人讨论、争辩`error` VS 异常的优点，我就不掺和了。但是，作为新手，的确需要我们明确的态度对待错误。我认为好的事情是，让你以期望的方式了解程序的每一步。

让事情明确，让开发者不变懒这几个理由使的Go安全。

另一个原因是Go有垃圾收集器。这不同于C/C++，不再需要程序员执行内存管理。C/C++程序里内存泄漏是内存管理困难的很大原因。有了GC减少了开发者的负担，使得程序总体安全。有些说，GC作为新生的东西还有很多改进的地方。我学习Go超过一年多，用Go写高性能的代码，开发者需要做更多的努力消除GC压力。

作为团队开发语言，安全是非常重要的。以为团队最终花费在处理内存错误的时间越来越少，花在功能开发上的时间越来越多。

##### Go强大
简单、高性能、先进概念如Channel,goroutine,interface，类型布局等使得Go很强大。我们在以上几节都讨论过。

除了以上，Go的杀手级功能就是Go编译后的程序是单个静态库，不用担心共享库的问题。也没有jar文件，没有库打包问题。对于部署、维护方面这是个机器强大的功能。部署、升级只要简单的拷贝单个库文件，仅此而已。

相比Node.js程序的部署，你可能需要下载数百小的包在部署的时候。同使也要担心所有这些包是否兼容。Node社区显然也开发了很多管理依赖和版本控制的工具。但我还是看到，每次部署Node app到新机器上，不得不下载几百个小的包，我对此有点绝望了。

假如你部署C/C++程序并依赖共享库，那么你就得担心OS和共享库兼容问题。

还有一个强大功能就是，Go可以在单个程序里混合使用C和汇编。我没有广泛的使用这些，但是在我试图优化[integer compression][]库，我加入一点C和汇编代码段，以从Go那里压榨出一点性能，做这相当的容易和直观。

最后，Go有很大并完整的标准库。使得开发者即快又有效率。随着语言的成熟和社区的成长，有很多第三方的开源库被补充进来。
##### 关于社区
今天，Go有非常活跃的社区，我常常从[go-nuts IRC][],[golang subreddit][]以及[golang-nuts mailing list][]获取信息。当我刚开始学习时，花了相当多的时间在IRC上，获得了相当多人的帮助，譬如dsal,tv42等等，我感谢他们。现在我很少花时间在上面了，因为时间有限(要知道，我的工作不是开发.:)

我觉得，开发社区里的个别开发者(gophers)，不愿意接受任何语言改变的反馈，对待来自不同语言开发者，问一些简单代码问题有点严厉。

很明显，即使在我还很菜的时候，也从没有花费大量时间在不同语言社区里。因此，我没有其他的可以比较，只能和人交流层面讲讲。

我能理解这两个方面，譬如，开发者来自不同语言背景，不同工作经历。
当他们用Go执行一样的任务，会问我怎样用X语言解决这个问题，怎样把它翻译成Go？

有时候，我也看到一些人说这不是Go工作的方式，你做的是错的。这样的回答，会很快产生负面情绪，并终止交流。

另一类型的回答者，告诉提问者：问的问题不对，然后贴一些关于怎样恰当提问的网页。我再一次体会到提问者，对这个事情的消极看法。

对于这些我自己的经历，那时去年，我实现[Bloom Filter][]包，我做了大量的性能测试并写了关于该包的文章。作为学习Go的新手，我感觉非常高兴完成了这个事情，把文章链接到reddit,得到第一个评论如下：
> 得到*倒赞*，因为我不喜欢这种学新语言的模式，并马上发布关于它的性能数据。你应该先知道怎样写Go的惯用法和高性能代码。

唉！！作为一个Go新手，这不是我期望的回应啊。不过，这个评论者指出并帮我改进了实现性能。我感谢他。我认识到为了减少Go GC压力，消减内存分配数量是多么重要。

事后想来，这个评论是一个非常关键的要点。我能理解，为什么一些开发者很恼怒，那些不知所云的基准测试。不管怎样，成为好的有礼貌的人，不是坏事情。像这样,"你的WEF是错误"的言论只会把新手推的远远的。

我能很快的跳出痛苦期，是因为我老于世故不关心别人怎么样。我通过写代码，优化Go代码继续我的学习，并发表我的文章到我的博客。实际上，[Go vs Java Decoding Billions of Integers Per Second][]这篇文章有很多优化技巧，我学习它，并尝试增加Go程序的性能。

然而总的来说，我感觉从Go社区学习到很多。人们通常都愿意帮助和分享问题的解决方案。我没什么比较，但是觉得Go社区大部分还是积极的。

### 结论
已经用Go愉快的工作了一年半了，看着语言和社区慢慢成长是很值得的一件事。我接下重点是，在个人有限的空闲时间里继续开发[SurgeMQ][],这是个MQTT代理和客户端库，目标是全面兼容MQTT 3.1和3.1.1规范。

[SurgeMQ]: https://github.com/surge/surgemq
[go-nuts IRC]: https://botbot.me/freenode/go-nuts/
[golang subreddit]: http://www.reddit.com/r/golang/search?q=golang&sort=new&restrict_sr=on&t=all
[golang-nuts mailing list]: https://groups.google.com/forum/#!forum/golang-nuts
[Go vs Java Decoding Billions of Integers Per Second]: http://zhen.org/blog/go-vs-java-decoding-billions-of-integers-per-second/
[2009 acquisition of SpringSource]: http://www.vmware.com/company/news/releases/springsource
[The way to Go]: http://www.amazon.com/gp/product/B0083RVAJW/ref=docs-os-doi_0
[Perlin Noise]: http://en.wikipedia.org/wiki/Perlin_noise
[Google’s Cityhash]: https://code.google.com/p/cityhash/
[bitmap compression]: https://github.com/dataence/bitmap
[integer compression]: https://github.com/dataence/encoding
[bloom filters]: https://github.com/dataence/bloom 
[skiplist]: https://github.com/dataence/skiplist
[blogged my journey]: http://zhen.org/blog/
[Language Specification]: https://golang.org/ref/spec
[Go Tour]: https://tour.golang.org/
[Summary of Go Generics Discussions]: https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4
[How to Write Go Code ]: https://golang.org/doc/code.html
[goimports]: https://github.com/bradfitz/goimports


